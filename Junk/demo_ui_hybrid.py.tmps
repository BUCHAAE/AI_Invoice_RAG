"""
Author: Andrew Buchanan  
Date: 26/04/2025  

Purpose:  
This script processes structured CSVs created from daycare invoices and attendance records. It builds a semantic vectorstore using sentence-transformer embeddings for retrieval-augmented generation. It also includes static facts such as the earliest attendance date to improve accuracy.

Narrative:
Snoopy is a cheerful Beagle owned by Charlie Brown. They live together in Bloomington, Minnesota. Each week, Snoopy attends doggy daycare at Pawprints & Playcare LLC, a local service offering structured care for dogs including supervised play sessions, rest periods, and social interaction. The facility is open seven days a week and is located on Willow Creek Drive. Every month, Pawprints & Playcare invoices Charlie Brown for Snoopy‚Äôs visits, applying a 50% loyalty discount. Over time, Snoopy has attended on a variety of weekdays, with Mondays being the most common. Detailed records of his attendance and invoices help Charlie ensure transparency and consistency in billing.
"""

# --- Optional: Gradio UI to query vectorstore immediately ---
import gradio as gr

import os
import pandas as pd
from datetime import datetime
from langchain_huggingface import HuggingFaceEmbeddings
from langchain_community.vectorstores import Chroma
from langchain.text_splitter import RecursiveCharacterTextSplitter

from langchain.chains import RetrievalQA
from langchain_ollama import OllamaLLM

from langchain.prompts import PromptTemplate

# --- Configuration ---
persist_directory = "chroma_db"
invoice_csv = "invoice_summary.csv"
attendance_csv = "attendance_detail.csv"
embedding_model_name = "BAAI/bge-small-en"

# --- Load CSVs ---
if not os.path.exists(invoice_csv) or not os.path.exists(attendance_csv):
    raise FileNotFoundError("‚ùå Required CSV files are missing. Please generate them first.")

print(f"üìÑ Reading {invoice_csv} and {attendance_csv}...")
invoice_df = pd.read_csv(invoice_csv)
attendance_df = pd.read_csv(attendance_csv)

# --- Static context enhancement ---
static_context = []

# Count and add total number of invoices to static context early for priority
invoice_count = len(invoice_df)
static_context.insert(0, f"There are {invoice_count} invoices on record for Snoopy's daycare visits. This value is from len(invoice_df), and each row represents an invoice line item.")


if not attendance_df.empty:
    try:
        attendance_df["ParsedDate"] = pd.to_datetime(attendance_df["Date"], format="%d/%m/%Y", errors="coerce")
        first_date = attendance_df["ParsedDate"].min()
        last_date = attendance_df["ParsedDate"].max()
        first_day = first_date.strftime("%A")
        last_day = last_date.strftime("%A")
        total_attendance = attendance_df["ParsedDate"].notna().sum()

        monthly_attendance = attendance_df["ParsedDate"].dt.to_period("M").value_counts().sort_index()
        avg_cost_per_day = invoice_df["TotalAmountDue"].sum() / total_attendance if total_attendance else 0
        attendance_by_day = attendance_df["Day"].fillna("Unknown").value_counts()
        most_common_day = attendance_by_day.idxmax()
        gaps = attendance_df["ParsedDate"].sort_values().diff().dt.days
        max_gap = int(gaps.max())
        unique_months = attendance_df["ParsedDate"].dt.to_period("M").nunique()

        static_context.append(
            f"Snoopy's first ever attendance at Pawprints and Playcare LLC was on {first_date.strftime('%d/%m/%Y')}, which was a {first_day}."
        )
        static_context.append(
            f"Snoopy's most recent attendance was on {last_date.strftime('%d/%m/%Y')}, which was a {last_day}."
        )
        static_context.append(f"Snoopy attended a total of {total_attendance} days.")
        static_context.append(f"Average cost per daycare visit: ${avg_cost_per_day:.2f}.")
        static_context.append(f"Snoopy most frequently attended on {most_common_day}s.")
        static_context.append(f"Longest gap between visits: {max_gap} days.")
        static_context.append(f"Snoopy attended during {unique_months} unique months.")
        static_context.append("Monthly attendance breakdown:")
        for month, count in monthly_attendance.items():
            static_context.append(f"- {month.strftime('%B %Y')}: {count} attendances")

    except Exception as e:
        static_context.append("Error parsing attendance details.")
else:
    static_context.append("No attendance records found.")

# --- Create invoice and attendance documents ---
print("üìÑ Generating documents for vectorstore...")

documents = []

# High-priority billing summary chunk (de-duplicated and prioritised)
billing_summary = f"There are {invoice_count} invoices in total. This count comes from len(invoice_df) and reflects every row in invoice_summary.csv. These represent actual line items, and this is the correct count. Please ignore any inferred invoice count based on invoice numbers like INV-2023-01 ‚Äî those are unique identifiers, not a count."
documents.insert(0, billing_summary)

# --- Create invoice and attendance documents ---
print("üìÑ Generating documents for vectorstore...")

documents = []

# Remove invoice details from vectorstore to avoid confusion

# Include individual attendance rows
#for _, row in attendance_df.iterrows():
#    documents.append(
#        f"{row['DogName']} attended on {row['Date']} ({row['Day']}) under invoice {row['InvoiceNumber']}."
#    )

for _, row in attendance_df.iterrows():
    documents.append(
        f"{row['DogName']} attended on {row['Date']} ({row['Day']})."
    )


# --- Append static context ---

# Add core narrative description
static_context.insert(0, "Snoopy is a cheerful Beagle owned by Charlie Brown. They live together in Bloomington, Minnesota. Each week, Snoopy attends doggy daycare at Pawprints & Playcare LLC, a local service offering structured care for dogs including supervised play sessions, rest periods, and social interaction. The facility is open seven days a week and is located on Willow Creek Drive. Every month, Pawprints & Playcare invoices Charlie Brown for Snoopy‚Äôs visits, applying a 50% loyalty discount. Over time, Snoopy has attended on a variety of weekdays, with Mondays being the most common. Detailed records of his attendance and invoices help Charlie ensure transparency and consistency in billing.")
documents.extend(static_context)

# --- Chunk text ---
text_splitter = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=50)
chunks = text_splitter.split_text("\n".join(documents))

print(f"‚úÇÔ∏è Split into {len(chunks)} text chunks.")

# --- Embeddings & vectorstore ---
print("üî¢ Creating vectorstore with embeddings...")

if os.path.exists(persist_directory):
    import shutil
    shutil.rmtree(persist_directory)

embedding = HuggingFaceEmbeddings(model_name=embedding_model_name)
vectorstore = Chroma.from_texts(chunks, embedding=embedding, persist_directory=persist_directory)

print("‚úÖ Vectorstore created successfully.")



# --- Custom prompt template ---
prompt_template = PromptTemplate(
    input_variables=["context", "question"],
    template=(
        "You are a helpful assistant answering only based on the context below."
        "Context:{context}"
        "Question: Answer as succinctly as possible. {question}"
        "Answer:"
    )
)


# Use Ollama LLM
print("\nüß† Launching Ollama-based Q&A UI...")
llm = OllamaLLM(model="llama3:instruct")

qa_chain = RetrievalQA.from_chain_type(
    llm=llm,
    retriever=vectorstore.as_retriever(),
    chain_type="stuff",
    chain_type_kwargs={"prompt": prompt_template},
    return_source_documents=False,
)

# Simple query handler
def ask_question(query, succinct):
    if succinct:
        query = "Answer as succinctly as possible. " + query
    response = qa_chain.invoke({"query": query})
    return response['result'].strip()  # Return only first sentence as a succinct answer

# Launch UI
gr.Interface(
    fn=ask_question,
    inputs=[
        gr.Textbox(lines=2, placeholder="Ask a question about Snoopy's invoices..."),
        gr.Checkbox(label="Make answer succinct", value=True)
    ],
    outputs=gr.Textbox(label="Answer"),
    title="Snoopy Invoice Q&A (LLM + Vectorstore)"
).launch()











































